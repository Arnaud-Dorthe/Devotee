#!/usr/bin/perl -w
#                              -*- Mode: Perl -*-
# debvote-mime.pl ---
# Author           : Manoj Srivastava ( srivasta@glaurung.green-gryphon.com )
# Created On       : Mon Mar 25 12:26:05 2002
# Created On Node  : glaurung.green-gryphon.com
# Last Modified By : Manoj Srivastava
# Last Modified On : Sun Apr 13 00:24:16 2003
# Last Machine Used: glaurung.green-gryphon.com
# Update Count     : 53
# Status           : Unknown, Use with caution!
# HISTORY          :
# Description      :
#
#


use strict;

require 5.005;
use Carp qw(carp croak);
use Fcntl ':flock'; # import LOCK_* constants
use Getopt::Long;

use MIME::Entity;
use MIME::Parser;
use MIME::Decoder;
use MIME::Tools;
use MIME::Decoder::Binary;

=head1 NAME

debvote-mime - From the work dir, decode and save the bidy of the message

=cut

=head1 SYNOPSIS

This routine is designed to handle various forms of MIME
encampulation, including PGP?MIME, and create a decoded body text in a
format that can be easily checked for cryptograhic signatures.

=cut

=head1 DESCRIPTION

The idea here is to be forgiving of MIME errors and be able to present
as many signed votes toi the signature verifier as possible.

Additionally, this script attempts to be idepotent. It is also
incremental, unless a force option is given. in which case it
re-decodes previously decoded messages.

=cut


=head2 Internal Implementation

=head3 extract_messages

This routine is where the grunt work occurs. After obtaining a lock
on the file in the sppol directory, we copy th efiles over to the work
directory, and wrte diagnostincs for any failure.

=cut

# Recursive routine for dumping an entity.
#
sub dump_entity {
  my ($bodydir, $msg, $entity) = @_;
  my $IO;

  # Output the body:
  my @parts = $entity->parts;
  if (@parts) {                     # multipart...
    my $i;
    foreach $i (0 .. $#parts) {       # dump each part...
      dump_entity($bodydir, $msg, $parts[$i]);
    }
  }
  else {                            # single part...
    # Get MIME type, and display accordingly...
    my ($type, $subtype) = split('/', $entity->head->mime_type);
    my $body = $entity->bodyhandle;
    if ($type =~ /^(text|message)$/ ) {     # text: display it...
      if ($IO = $body->open("r")) {
	my $ret = open(DATA, ">>$bodydir/$msg");
	if (!$ret) {
	  &log_message($msg, "Could not create output $bodydir/$msg");
	  return;
	}
	chmod 0660, "$bodydir/$msg";
	print DATA $_ while (defined($_ = $IO->getline));
	$IO->close;
	close DATA;
      }
      else {       # d'oh!
	&log_message($msg, "couldn't find/open part: $!");
      }
    }
    elsif ($type =~ /^application$/ && $subtype=~ /^pgp$/) {
      my $disposition = $entity->head->mime_attr("content-disposition");
      if ($disposition && $disposition =~ /^inline$/) {
	if ($IO = $body->open("r")) {
	  my $ret = open(DATA, ">>$bodydir/$msg");
	  if (!$ret) {
	    &log_message($msg, "Could not create output $bodydir/$msg");
	    return;
	  }
	  chmod 0660, "$bodydir/$msg";
	  print DATA $_ while (defined($_ = $IO->getline));
	  $IO->close;
	  close DATA;
	}
	else {       # d'oh!
	  &log_message($msg, "Could not create output $bodydir/$msg");
	  return;
	}
      }
    }
    else {
      my $eff_type = $entity->effective_type;
      my $disposition = $entity->head->mime_attr("content-disposition");
#     &log_message($msg, "effective type [" . $eff_type .
#	   "] disposition [" . $disposition . "]");
      return;
    }
  }
  1;
}


sub extract_messages {
  my %params   = @_;
  die "Internal Error!" unless defined $params{'Configuration'};
  my $confref = $params{'Configuration'}->get_config_ref();
  my $dvt = $params{'Configuration'};
  my %Config = %{ $confref };

  my $topdir      = $Config{'Top_Dir'};
  my $workdir     = $Config{'Work_Dir'};
  my $bodydir     = $Config{'Body_Dir'};
  my $logdir      = $Config{'Log_Dir'};


  my $lock_suffix = $Config{'Lock_Suffix'};
  my $msg_suffix  = $Config{'Msg_Suffix'};
  my $msg_preffix = $Config{'Msg_Preffix'};
  my $common_lock = $Config{'Common_Lock'};
  my $force       = $Config{'Force'};
  my $tmpdir      = $Config{'Temp_Dir'};
  my $body_suffix = $Config{'Body_Suffix'};
  my $sig_suffix  = $Config{"Sig_Suffix"};

  opendir(WORK, $workdir) || die "can't opendir $workdir: $!";
  my @messages = grep { m/${msg_preffix}\d+\.${msg_suffix}$/ &&
                        -f  "$workdir/$_" }   readdir(WORK);
  closedir(WORK);

  my $msg         ;
  foreach $msg (sort @messages) {
    next if !$force && -e "$bodydir/$msg";

    my $parser = new MIME::Parser;
    $parser->output_dir("$tmpdir");
    $parser->output_to_core(0);

    my $entity;
    eval {$entity = $parser->parse_open("$workdir/$msg"); };
    if ($@) {
      &log_message($msg, "Could not parse message $msg");
      next;
    }

    dump_entity($bodydir, $msg, $entity);
  }
}



=head1 OPTIONS

=over 4

=item B<-c> F<config file>, B<--config_file>=F<config file>

Specify an alternate configuration file to read in for this run. Note:
this script does not do any sophisticated option parsing or checking.

=item B-f>, B<--force>

Redo the copy even if the destination file already exists.

=back

=cut

use Devotee;
sub main {
  my $optdesc = Devotee->Optdesc();
  GetOptions (%$optdesc);
  my $dvt = Devotee->new(%::ConfOpts);
  $dvt->validate(%::ConfOpts) unless 
    defined $::ConfOpts{'Config File'} && -r $::ConfOpts{'Config File'};
  $dvt->lock_vote_dir();
  &extract_messages('Configuration' => $dvt);
  $dvt->unlock_vote_dir();
}

&main;

exit 0;
