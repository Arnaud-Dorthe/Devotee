#!/usr/bin/perl -w
#                              -*- Mode: Cperl -*- 
# dvt-rslt --- 
# Author           : Manoj Srivastava ( srivasta@glaurung.green-gryphon.com ) 
# Created On       : Thu Oct 16 12:08:43 2003
# Created On Node  : glaurung.green-gryphon.com
# Last Modified By : Manoj Srivastava
# Last Modified On : Sun Mar 12 01:23:06 2006
# Last Machine Used: glaurung.internal.golden-gryphon.com
# Update Count     : 140
# Status           : Unknown, Use with caution!
# HISTORY          : 
# Description      : 
# arch-tag: 1a48504a-0668-4790-aa72-d4359a3c41e2
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# 

use strict;

require 5.005;
use Carp qw(carp croak);
use Devotee;
use Getopt::Long;


=head1 NAME

dvt-rslt - Given a tally sheet, calculate the Condorcet winner

=cut

=head1 SYNOPSIS

dvt-rslt -c /path/to/config 

=cut

=head1 DESCRIPTION

Produce the results, taking into consideration the tally, quorum
requirements, and the per option majority requirements, if any.
This routine is the heart of the voting system. It takes into account
quorum requirements (reading the output file produced by dvt-quorum),
and also the configured majority requirements, if any.

It reads the tally sheet produced by dvt-tally, and creates the
initial beat matrix; and the pairwise defeat list, and finally the
schwartz set. If there are defeats between the members of the schwartz
set, it drops the weakest defeat and repeats, until there is a winner.

It puts the results in the configured output file.

=cut

=head2 Internal Implementation

=head3 winner

This is the workhorse routine. 
This routine pays attention to the configuration variables
Quorum_File, Tally_File, Max_Choices, and Results.

=cut

sub winner {
  my %params   = @_;
  die "Internal Error!" unless defined $params{'Configuration'};
  my $confref = $params{'Configuration'}->get_config_ref();
  my $dvt = $params{'Configuration'};
  my %Config = %{ $confref };

  my $quorum_file = $Config{"Quorum_File"};
  my $tallyfile   = $Config{'Tally_File'};
  my $max_choices = $Config{'Max_Choices'};
  my $html_file   = $Config{'HTML_Result'};
  my $results     = $Config{'Results'};
  my $graph       = $Config{'Graph'};

  # The constitution defines the maximum value of K to be 5
  my $K = 5;

  # FIXME: this really should be optional
  open(QUORUM, "$quorum_file") ||  die "Could not open $quorum_file:$!";
  while (<QUORUM>) {
    next unless m/\s*Quorum[^=]+=\s*(\S+)/;
    $K = $1;
  }

  #   1. Given two options A and B, V(A,B) is the number of voters who
  #      prefer option A over option B.
  my @Beat_Matrix = ();
  for my $row (0..$max_choices) {
    for my $col (0..$max_choices) {
      $Beat_Matrix[$row][$col] = 0;
    }
  }

  # OK. Start creating an output file.
  open (RESULTS, ">$results") || die "Could not open $results:$!";
  chmod $Config{"File_Mask"}, "$results";
  open (HTMLOUT, ">$html_file") || die "Could not open $html_file:$!";
  chmod $Config{"File_Mask"}, "$html_file";

  my $now_string = gmtime;
  print RESULTS "Starting results calculation at $now_string\n\n";

  # This is where we get our input data from
  open(TALLY, "$tallyfile") ||  die "Could not open $tallyfile:$!";
  while (<TALLY>) {
    chomp;
    next unless m/^V:\s+(\S+)\s+(\S+)/;
    my $vote = $1;
    my $voter = $2;

    my @rank = unpack "a" x $max_choices, $vote;
    foreach my $i (0..($max_choices - 1)) {
      foreach my $j (($i + 1)..($max_choices - 1)) {
        if ($rank[$i] eq '-' && $rank[$j] eq '-') {
          next;                 # Both unranked
        } elsif ($rank[$i] eq '-' && $rank[$j] ne '-') {
          $Beat_Matrix[$j][$i]++;
        } elsif ($rank[$i] ne '-' && $rank[$j] eq '-') {
          $Beat_Matrix[$i][$j]++;
        } elsif ($rank[$i] < $rank[$j]) {
          $Beat_Matrix[$i][$j]++;
        } elsif ($rank[$i] > $rank[$j]) {
          $Beat_Matrix[$j][$i]++;
        } else {
          next;                 # Equally ranked
        }
      }
    }
  }
  print HTMLOUT <<PREAMBLE;
            <p>
               In the following table, tally[row x][col y] represents
               the votes that option x received over option y. A 
               <a href="http://en.wikipedia.org/wiki/Schwartz_method">more
                 detailed explanation of the beat matrix</a> may help in
               understanding the table. For understanding the Condorcet method, the
               <a href="http://en.wikipedia.org/wiki/Condorcet_method">Wikipedia
                 entry</a> is fairly informative.
           </p>
           <ul>
PREAMBLE

  for my $opt (0..($max_choices - 1)) {
    print RESULTS "Option ", $opt + 1, " \"", $Config{"Option_" . ($opt + 1)},
      "\"\n";
    print HTMLOUT "<li>Option ", $opt + 1, " \"", 
      $Config{"Option_" . ($opt + 1)}, "\"</li>\n";
  }
  print RESULTS <<EOF;

In the following table, tally[row x][col y] represents the votes that
option x received over option y.

EOF
  ;
  print HTMLOUT <<POSTAMBLE;
           </ul>
           <table class="vote">
             <caption class="center"><strong>The Beat Matrix</strong></caption>
             <tr><th colspan="$max_choices" class="center">Option</th></tr>
              <tr>
                   <th>\&nbsp;</th>
POSTAMBLE
  ;

  print RESULTS " " x18, "Option\n";
  print RESULTS " " x10;
  for my $col (0..($max_choices - 1)) {
    printf RESULTS " % 4d ", $col + 1;
    printf HTMLOUT "                   <th> % 4d </th>\n", $col + 1;
  }

  print RESULTS "\n";
  print RESULTS " " x10, "  === " x $max_choices, "\n";

  print HTMLOUT "              </tr>\n";

  for my $row (0..($max_choices - 1)) {
    printf RESULTS "Option %d  ", $row + 1;
    printf HTMLOUT "                 <tr>\n";
    printf HTMLOUT "                   <th>Option %d  </th>\n", $row + 1;
    for my $col (0..($max_choices - 1)) {
      if ($row == $col) {
        printf HTMLOUT "                   <td>\&nbsp;</td>\n";
        printf RESULTS "      ", $Beat_Matrix[$row][$col];
      } else {
        printf HTMLOUT "                   <td> % 4d </td>\n", $Beat_Matrix[$row][$col];
        printf RESULTS " % 4d ", $Beat_Matrix[$row][$col];
      }
    }
    printf HTMLOUT "                 </tr>\n";
    print RESULTS "\n";
  }
  print RESULTS "\n\n";
  print HTMLOUT "               </table>\n";
  print HTMLOUT "              <p>\n";
  print HTMLOUT <<EOEXP;

Looking at row 2, column 1, $Config{Option_2}<br/>
received $Beat_Matrix[1][0] votes over $Config{Option_1}<br/>
<br/>
Looking at row 1, column 2, $Config{Option_1}<br/>
received $Beat_Matrix[0][1] votes over $Config{Option_2}.<br/>
EOEXP

  print RESULTS <<EOM;

Looking at row 2, column 1, $Config{Option_2}
received $Beat_Matrix[1][0] votes over $Config{Option_1}

Looking at row 1, column 2, $Config{Option_1}
received $Beat_Matrix[0][1] votes over $Config{Option_2}.

EOM
  ;
  
  my %Drop = ();

  print HTMLOUT "              <h3>Quorum</h3>\n";
  print HTMLOUT "              <ul>\n";
  foreach my $i (0..($max_choices - 2)) {
    if ($Beat_Matrix[$i][$max_choices - 1] < $K) {
      $Drop{$i}++;
      print HTMLOUT "                <li>Dropping Option", $i + 1, 
        " \"", $Config{"Option_" . ($i + 1)}, "\" because of Quorum</li>\n";
      print RESULTS "Dropping Option", $i + 1, " \"", $Config{"Option_" . ($i + 1)}, 
        "\" because of Quorum\n";
    } else {
      print HTMLOUT "                <li>Option", $i + 1, 
        " Reached quorum: $Beat_Matrix[$i][$max_choices - 1] \&gt; $K</li>\n";
      print RESULTS "Option ", $i + 1, 
        " Reached quorum: $Beat_Matrix[$i][$max_choices - 1] > $K\n";
    }
  }
  print HTMLOUT "              </ul>\n";

  print RESULTS "\n\n";

  #   2. An option A defeats the default option D by a majority ratio N,
  #   if V(A,D) is strictly greater than N * V(D,A).
  #   3. If a supermajority of S:1 is required for A, its majority ratio
  #   is S; otherwise, its majority ratio is 1.
  #  Any (non-default) option which does not defeat the default option
  #  by its required majority ratio is dropped from consideration.
  print HTMLOUT "              <h3>Majority</h3>\n";
  print HTMLOUT "              <ul>\n";
  foreach my $i (0..($max_choices - 2)) {
    next unless $Beat_Matrix[$max_choices - 1][$i];
    next if $Drop{$i};

    my $ratio = $Beat_Matrix[$i][$max_choices - 1] /
      $Beat_Matrix[$max_choices - 1][$i];
    if ($ratio <= $Config{"Majority_" . ($i + 1)}) {
      # If the next line is commented out, we get a more verbose set of results
      $Drop{$i}++;
      print HTMLOUT "                <li>Dropping Option", $i + 1, 
        " because of Majority. ";
      printf HTMLOUT " %6.3f (%d/%d) \&lt;= %d</li>\n",
        $ratio, $Beat_Matrix[$i][$max_choices - 1],
          $Beat_Matrix[$max_choices - 1][$i],
            $Config{"Majority_" . ($i + 1)};

      print RESULTS "Dropping Option ", $i + 1, " because of Majority.";
      printf RESULTS " %6.3f (%d/%d) < %d\n",
        $ratio, $Beat_Matrix[$i][$max_choices - 1],
          $Beat_Matrix[$max_choices - 1][$i],
            $Config{"Majority_" . ($i + 1)};
    } else {
      print HTMLOUT "                <li>Option", $i + 1, 
        " passes Majority.\n";
      printf HTMLOUT " %6.3f (%d/%d) \&gt; %d</li>\n",
        $ratio, $Beat_Matrix[$i][$max_choices - 1],
          $Beat_Matrix[$max_choices - 1][$i],
            $Config{"Majority_" . ($i + 1)};


      print RESULTS "Option ", $i + 1, " passes Majority.";
      print RESULTS "             ";
      printf RESULTS " %6.3f (%d/%d) > %d\n",
        $ratio, $Beat_Matrix[$i][$max_choices - 1],
          $Beat_Matrix[$max_choices - 1][$i],
            $Config{"Majority_" . ($i + 1)};
    }
  }
  print HTMLOUT "              </ul>\n";
  print RESULTS "\n\n";

  my $done = 0;
  my %Defeats;
  # Initialize the Defeats matrix
  print HTMLOUT "              <h3>Pair-wise defeats</h3>\n";
  print HTMLOUT "              <ul>\n";
  foreach my $i (0..($max_choices - 1)) {
    next if $Drop{$i};
    foreach my $j (($i + 1)..($max_choices - 1)) {
      next if $Drop{$j};
      if ($Beat_Matrix[$i][$j] > $Beat_Matrix[$j][$i]) {
        # i defeats j
        $Defeats{$i}{$j}{for}     = $Beat_Matrix[$i][$j];
        $Defeats{$i}{$j}{against} = $Beat_Matrix[$j][$i];

        print HTMLOUT "                <li>Option ", $i + 1, " defeats Option ",
          $j + 1, sprintf(" by (% 4d - % 4d) = %4d votes.</li>\n", $Beat_Matrix[$i][$j],
                          $Beat_Matrix[$j][$i], 
                          $Beat_Matrix[$i][$j] - $Beat_Matrix[$j][$i]);

        print RESULTS "  Option ", $i + 1, " defeats Option ",
          $j + 1, sprintf(" by (% 4d - % 4d) = %4d votes.\n", $Beat_Matrix[$i][$j],
                          $Beat_Matrix[$j][$i], 
                          $Beat_Matrix[$i][$j] - $Beat_Matrix[$j][$i]);
      } elsif ($Beat_Matrix[$i][$j] < $Beat_Matrix[$j][$i]) {
        # j defeats i
        $Defeats{$j}{$i}{for}     = $Beat_Matrix[$j][$i];
        $Defeats{$j}{$i}{against} = $Beat_Matrix[$i][$j];

        print HTMLOUT "                <li>Option ", $j + 1, " defeats Option ",
          $i + 1, sprintf(" by (% 4d - % 4d) = %4d votes.</li>\n", $Beat_Matrix[$j][$i],
                          $Beat_Matrix[$i][$j], 
                          $Beat_Matrix[$j][$i] - $Beat_Matrix[$i][$j]);


        print RESULTS "  Option ", $j + 1, " defeats Option ",
          $i + 1, sprintf(" by (% 4d - % 4d) = %4d votes.\n", $Beat_Matrix[$j][$i],
                          $Beat_Matrix[$i][$j], 
                          $Beat_Matrix[$j][$i] - $Beat_Matrix[$i][$j]);
      }
    }
  }
  print HTMLOUT "              </ul>\n";
  print RESULTS "\n\n";
  my %BeatPath;
  my @Schwartz;
  # Ok, here is what we are here for.
  while (1) {

    # From the list of [undropped] pairwise defeats, we generate a set of
    # transitive defeats.

    # Initialize the Beatpath
    undef %BeatPath;
    foreach my $i (0..($max_choices - 1)) {
      next if $Drop{$i};
      foreach my $j (0..($max_choices - 1)) {
        next if $Drop{$j};
        $BeatPath{$i}{$j}{for}     = $Defeats{$i}{$j}{for};
        $BeatPath{$i}{$j}{against} = $Defeats{$i}{$j}{against};
      }
    }

    #   1. An option A transitively defeats an option C if A defeats C or
    #      if there is some other option B where A defeats B AND B
    #      transitively defeats C.
    while (!$done) {
      $done = 1;
      foreach my $i (0..($max_choices - 1)) {
        next if $Drop{$i};
        foreach my $j (0..($max_choices - 1)) {
          next if $Drop{$j};
          next if $i == $j;
          foreach my $k (0..($max_choices - 1)) {
            next if $Drop{$k};
            next if $i == $k;
            next if $k == $j;
            if (!$BeatPath{$i}{$j}{for}) {
              if ($BeatPath{$i}{$k}{for} && $BeatPath{$k}{$j}{for} ) {
                if ($BeatPath{$i}{$k}{for} == $BeatPath{$k}{$j}{for}) {
                  $BeatPath{$i}{$j}{for} = ($BeatPath{$i}{$k}{against} > 
                                            $BeatPath{$k}{$j}{against}) ?
                                              $BeatPath{$i}{$k}{for}:$BeatPath{$k}{$j}{for};
                  $BeatPath{$i}{$j}{against} = ($BeatPath{$i}{$k}{against} > 
                                                $BeatPath{$k}{$j}{against}) ?
                                                  $BeatPath{$i}{$k}{against} :
                                                    $BeatPath{$k}{$j}{against};
                } else {
                  $BeatPath{$i}{$j}{for} = ($BeatPath{$i}{$k}{for} < 
                                            $BeatPath{$k}{$j}{for}) ?
                                              $BeatPath{$i}{$k}{for} : 
                                                $BeatPath{$k}{$j}{for};
                  $BeatPath{$i}{$j}{against} = ($BeatPath{$i}{$k}{for} < 
                                                $BeatPath{$k}{$j}{for}) ?
                                                  $BeatPath{$i}{$k}{against} :
                                                    $BeatPath{$k}{$j}{against};
                }
                $done = 0;
              }
            }
          }
        }
      }
    }


    # We construct the Schwartz set from the set of transitive defeats.
    foreach my $i (0..($max_choices - 1)) {
      if ($Drop{$i}) {
        $Schwartz[$i] = 0;
      } else {
        $Schwartz[$i] = 1;
      }
    }

    foreach my $i (0..($max_choices - 1)) {
      foreach my $j (0..($max_choices - 1)) {
        next if $i == $j;
        # An option A is in the Schwartz set if for all options B, either
        # A transitively defeats B, or B does not transitively defeat A
        # Here, we throw out any option $i that does not meet the above
        # criteria.
        if (! ($BeatPath{$i}{$j}{for} || ! $BeatPath{$j}{$i}{for})) {
          $Schwartz[$i] = 0;
        }
      }
    }
    print HTMLOUT "              <h3>The Schwartz Set contains</h3>\n";
    print HTMLOUT "              <ul>\n";
    print RESULTS "The Schwartz Set contains:\n";
    foreach my $i (0 ..$#Schwartz) {
      next unless $Schwartz[$i];
      print HTMLOUT "                <li>Option ", ($i + 1), " \"", 
        $Config{"Option_" . ($i + 1)}, "\"</li>\n";
      print RESULTS "\t Option ", ($i + 1), " \"", 
        $Config{"Option_" . ($i + 1)}, "\"\n";
    }
    print HTMLOUT "              </ul>\n";
    print RESULTS "\n\n";

    # If there are defeats between options in the Schwartz set, we drop
    # the weakest such defeats from the list of pairwise defeats, and
    # return to step 5.

    #  1. A defeat (A,X) is weaker than a defeat (B,Y) if V(A,X) is
    #     less than V(B,Y). Also, (A,X) is weaker than (B,Y) if V(A,X) is
    #     equal to V(B,Y) and V(X,A) is greater than V(Y,B).

    #  2. A weakest defeat is a defeat that has no other defeat weaker
    #  than it. There may be more than one such defeat.

    # Check to see if there is anything in the Schwartz set that has no
    # defeats.
    my %Weakest;
    my $weak_count = 0;
    foreach my $i (0 ..$#Schwartz) {
      next unless $Schwartz[$i];
      foreach my $j (0..$#Schwartz) {
        next unless $Schwartz[$j];
        next if $i == $j;
        if (defined $Defeats{$i}{$j}{'for'}) {
          if (! $weak_count) {
            $Weakest{$weak_count}{'for'}     = $Defeats{$i}{$j}{for};
            $Weakest{$weak_count}{'against'} = $Defeats{$i}{$j}{against};
            $Weakest{$weak_count}{'Winner'}  = $i;
            $Weakest{$weak_count}{'Loser'}   = $j;
            $weak_count++;
          } elsif ($Weakest{0}{'for'} > $Defeats{$i}{$j}{for}) {
            undef %Weakest;
            $weak_count = 0;
            $Weakest{$weak_count}{'for'}     = $Defeats{$i}{$j}{for};
            $Weakest{$weak_count}{'against'} = $Defeats{$i}{$j}{against};
            $Weakest{$weak_count}{'Winner'}  = $i;
            $Weakest{$weak_count}{'Loser'}   = $j;
            $weak_count++;
          } elsif ($Weakest{0}{'for'} == $Defeats{$i}{$j}{'for'}) {
            if ($Weakest{0}{'against'} < $Defeats{$i}{$j}{against}) {
              undef %Weakest;
              $weak_count = 0;
              $Weakest{$weak_count}{'for'}     = $Defeats{$i}{$j}{for};
              $Weakest{$weak_count}{'against'} = $Defeats{$i}{$j}{against};
              $Weakest{$weak_count}{'Winner'}  = $i;
              $Weakest{$weak_count}{'Loser'}   = $j;
              $weak_count++;
            } else {
              $Weakest{$weak_count}{'for'}     = $Defeats{$i}{$j}{'for'};
              $Weakest{$weak_count}{'against'} = $Defeats{$i}{$j}{'against'};
              $Weakest{$weak_count}{'Winner'}  = $i;
              $Weakest{$weak_count}{'Loser'}   = $j;
              $weak_count++;
            }
          }
        }
        if (defined $Defeats{$j}{$i}{'for'}) {
          if (! $weak_count) {
            $Weakest{$weak_count}{'for'}     = $Defeats{$j}{$i}{'for'};
            $Weakest{$weak_count}{'against'} = $Defeats{$j}{$i}{'against'};
            $Weakest{$weak_count}{'Winner'}  = $j;
            $Weakest{$weak_count}{'Loser'}   = $i;
            $weak_count++;
          } elsif ($Weakest{0}{'for'} > $Defeats{$j}{$i}{'for'}) {
            undef %Weakest;
            $weak_count = 0;
            $Weakest{$weak_count}{'for'}     = $Defeats{$j}{$i}{'for'};
            $Weakest{$weak_count}{'against'} = $Defeats{$j}{$i}{'against'};
            $Weakest{$weak_count}{'Winner'}  = $j;
            $Weakest{$weak_count}{'Loser'}   = $i;
            $weak_count++;
          } elsif ($Weakest{0}{'Low'} == $Defeats{$j}{$i}{'for'}) {
            if ($Weakest{0}{'against'} < $Defeats{$j}{$i}{'against'}) {
              undef %Weakest;
              $weak_count = 0;
              $Weakest{$weak_count}{'for'}    = $Defeats{$j}{$i}{'for'};
              $Weakest{$weak_count}{'against'} = $Defeats{$j}{$i}{'against'};
              $Weakest{$weak_count}{'Winner'} = $j;
              $Weakest{$weak_count}{'Loser'}  = $i;
              $weak_count++;
            } else {
              $Weakest{$weak_count}{'for'}     = $Defeats{$j}{$i}{'for'};
              $Weakest{$weak_count}{'against'} = $Defeats{$j}{$i}{'against'};
              $Weakest{$weak_count}{'Winner'}  = $j;
              $Weakest{$weak_count}{'Loser'}   = $i;
              $weak_count++;
            }
          }
        }
      }
    }
    if (! $weak_count) {
      print RESULTS "\n", "-=" x 35, "\n";
      print RESULTS "-=" x 35, "\n\n";
      print HTMLOUT "              <h3>The winners</h3>\n";
      print HTMLOUT "              <ul>\n";
      print RESULTS "The winners are:\n";
      foreach my $i (0 ..$#Schwartz) {
        next unless $Schwartz[$i];
        print HTMLOUT "                <li>Option ", ($i + 1), " \"", 
          $Config{"Option_" . ($i + 1)}, "\"</li>\n";
        print RESULTS "\t Option ", ($i + 1), " \"", 
          $Config{"Option_" . ($i + 1)}, "\"\n";
      }
      print HTMLOUT "              </ul>\n";
      print RESULTS "\n", "-=" x 35, "\n";
      print RESULTS "-=" x 35, "\n\n";
      last;
    } else {
      print RESULTS "Weakest Defeat(s): \n";
      print HTMLOUT "              <h3>Weakest Defeat(s)</h3>\n";
      print HTMLOUT "              <ul>\n";
      foreach my $k (sort keys %Weakest) {
        print HTMLOUT "                <li>Option ", $Weakest{$k}{'Winner'} + 1, " beats Option ",
          $Weakest{$k}{'Loser'} + 1, " by ",
            " ($Beat_Matrix[$Weakest{$k}{'Winner'}][$Weakest{$k}{'Loser'}] - ",
              "$Beat_Matrix[$Weakest{$k}{'Loser'}][$Weakest{$k}{'Winner'}])\t",
                "= ", $Weakest{$k}{'for'} - $Weakest{$k}{'against'}, " votes</li>\n";

        print RESULTS "\tOption ", $Weakest{$k}{'Winner'} + 1, " beats Option ",
          $Weakest{$k}{'Loser'} + 1, " by ",
            " ($Beat_Matrix[$Weakest{$k}{'Winner'}][$Weakest{$k}{'Loser'}] - ",
              "$Beat_Matrix[$Weakest{$k}{'Loser'}][$Weakest{$k}{'Winner'}])\t",
                "= ", $Weakest{$k}{'for'} - $Weakest{$k}{'against'}, " votes\n";
      }
      print HTMLOUT "              </ul>\n";
      print HTMLOUT "              <p>Deleting weakest defeat(s)</p>\n";
      print RESULTS "Deleting weakest defeat(s)\n\n";
      foreach my $k (sort keys %Weakest) {
        delete $Defeats{$Weakest{$k}{'Winner'}}{$Weakest{$k}{'Loser'}};
      }
    }
  }

  print HTMLOUT <<BOTTOM;
              <p>
               Debian uses the Condorcet method voting.
               Simplistically, plain Condorcets method
               can be stated like so : <br/>
               <q>Consider all possible two-way races between candidates.
                  The Condorcet winner, if there is one, is the one
                  candidate who can beat each other candidate in a two-way
                  race with that candidate.</q>
               The problem is that in complex elections, there may well
               be a circular relations ship in which A beats B, B beats C,
               and C beats A. Most of the variations on Condorcet use
               various means of resolving the tie. See
               <a href="http://en.wikipedia.org/wiki/Cloneproof_Schwartz_Sequential_Dropping">Cloneproof Schwartz Sequential Dropping</a>
               for details. Debian's variation is spelled out in the
               <a href="\$(HOME)/devel/constitution">the constitution</a>,
               specifically,  A.6.
              </p>
BOTTOM

  # Create the graphical results file in dot format.
  open (GRAPH, ">$graph") || die "Could not open $graph:$!";
  chmod $Config{"File_Mask"}, "$graph";
  # The header. This is a directed graph.
  print GRAPH "digraph Results {\n  ranksep=0.25;\n";
  foreach my $i (0..($max_choices - 1)) {
    # At this point, the Schwartz set is in place and contains all the
    # winners (who get a different color fill)

    # Print Node information.
    print GRAPH " \"", $Config{"Option_" . ($i + 1)}, "\" [ style=\"filled\" ";
    if ($Schwartz[$i]) {
      print GRAPH ", color=\"powderblue\", shape=egg, fontcolor=\"Navy Blue\"";
    }
    if ($i == ($max_choices - 1)) {
      print GRAPH ", shape=diamond, fontcolor=\"Red\"";
    }
    if ($Drop{$i}) {
      print GRAPH ", color=\"pink\", shape=octagon";
    }
    print GRAPH ", fontname=\"Helvetica\", fontsize=10  ];\n";

    if ($Drop{$i}) {
      if ($Beat_Matrix[$i][$max_choices - 1] >= $K) {
        # it met quorum, but still was dropped.
        # probably since it did not meet majority
        my $label = $Beat_Matrix[$max_choices -1][$i] - 
          $Beat_Matrix[$i][$max_choices -1];
        # my $win;
        # $win = $label;
        # "weight=", ((($win<0)?-1:1) * 1000/$win),
        print GRAPH " \"", $Config{"Option_" . $max_choices}, "\" -> \"",
          $Config{"Option_" . ($i + 1)}, "\" [ label=\"$label\" ];\n";
      }
    }
    foreach my $j (0..($max_choices - 1)) {
      next if $i == $j;
      #  The beatpath should take into account transitive wins, and
      #  have had all the weakest links removed, if needed, to resolve
      #  circular ties.
      if ($BeatPath{$i}{$j}{for}) {
        # my $win   = $BeatPath{$i}{$j}{for};
        # $win   -= $BeatPath{$j}{$i}{against}
        #  if defined $BeatPath{$j}{$i}{against};
        # "weight=", (1000/$win),

        # We still use the simple two way contest margins to label the
        # edge, since anything else is likely to confuse people.
        my $label = $Beat_Matrix[$i][$j] - $Beat_Matrix[$j][$i];

        # Print the edge information.
        print GRAPH " \"", $Config{"Option_" . ($i + 1)}, "\" -> \"",
          $Config{"Option_" . ($j + 1)}, "\" [ label=\"$label\" ];\n";
      }
    }
  }
  # The footer.
  print GRAPH "}\n";

}


sub main {
  my $optdesc = Devotee->Optdesc();
  GetOptions (%$optdesc);
  my $dvt = Devotee->new(%::ConfOpts);
  $dvt->validate(%::ConfOpts) unless 
    defined $::ConfOpts{'Config File'} && -r $::ConfOpts{'Config File'};
  &winner('Configuration' => $dvt);
}

&main;

exit 0;


=head1 CAVEATS

This is very inchoate, at the moment, and needs testing.

=cut

=head1 BUGS

None Known so far.

=cut

=head1 AUTHOR

Manoj Srivastava <srivasta@debian.org>

=head1 COPYRIGHT AND LICENSE

This script is a part of the Devotee package, and is 

Copyright (c) 2002, 2003, 2004, 2005  Manoj Srivastava <srivasta@debian.org>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=cut



1;

__END__

