#!/usr/bin/perl -w
#                              -*- Mode: Cperl -*- 
# dvt-rslt --- 
# Author           : Manoj Srivastava ( srivasta@glaurung.green-gryphon.com ) 
# Created On       : Thu Oct 16 12:08:43 2003
# Created On Node  : glaurung.green-gryphon.com
# Last Modified By : Manoj Srivastava
# Last Modified On : Thu Dec 15 09:27:02 2005
# Last Machine Used: glaurung.internal.golden-gryphon.com
# Update Count     : 139
# Status           : Unknown, Use with caution!
# HISTORY          : 
# Description      : 
# arch-tag: 1a48504a-0668-4790-aa72-d4359a3c41e2
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# 

use strict;

require 5.005;
use Carp qw(carp croak);
use Devotee;
use Getopt::Long;


=head1 NAME

dvt-rslt - Given a tally sheet, calculate the Condorcet winner

=cut

=head1 SYNOPSIS

dvt-rslt -c /path/to/config 

=cut

=head1 DESCRIPTION

Produce the results, taking into consideration the tally, quorum
requirements, and the per option majority requirements, if any.
This routine is the heart of the voting system. It takes into account
quorum requirements (reading the output file produced by dvt-quorum),
and also the configured majority requirements, if any.

It reads the tally sheet produced by dvt-tally, and creates the
initial beat matrix; and the pairwise defeat list, and finally the
schwartz set. If there are defeats between the members of the schwartz
set, it drops the weakest defeat and repeats, until there is a winner.

It puts the results in the configured output file.

=cut

=head2 Internal Implementation

=head3 winner

This is the workhorse routine. 
This routine pays attention to the configuration variables
Quorum_File, Tally_File, Max_Choices, and Results.

=cut

sub winner {
  my %params   = @_;
  die "Internal Error!" unless defined $params{'Configuration'};
  my $confref = $params{'Configuration'}->get_config_ref();
  my $dvt = $params{'Configuration'};
  my %Config = %{ $confref };

  my $quorum_file = $Config{"Quorum_File"};
  my $tallyfile   = $Config{'Tally_File'};
  my $max_choices = $Config{'Max_Choices'};
  my $results     = $Config{'Results'};
  my $graph       = $Config{'Graph'};

  # The constitution defines the maximum value of K to be 5
  my $K = 5;

  # FIXME: this really should be optional
  open(QUORUM, "$quorum_file") ||  die "Could not open $quorum_file:$!";
  while (<QUORUM>) {
    next unless m/\s*Quorum[^=]+=\s*(\S+)/;
    $K = $1;
  }

  #   1. Given two options A and B, V(A,B) is the number of voters who
  #      prefer option A over option B.
  my @Beat_Matrix = ();
  for my $row (0..$max_choices) {
    for my $col (0..$max_choices) {
      $Beat_Matrix[$row][$col] = 0;
    }
  }

  # OK. Start creating an output file.
  open (RESULTS, ">$results") || die "Could not open $results:$!";
  chmod $Config{"File_Mask"}, "$results";

  my $now_string = gmtime;
  print RESULTS "Starting results calculation at $now_string\n\n";

  # This is where we get our input data from
  open(TALLY, "$tallyfile") ||  die "Could not open $tallyfile:$!";
  while (<TALLY>) {
    chomp;
    next unless m/^V:\s+(\S+)\s+(\S+)/;
    my $vote = $1;
    my $voter = $2;

    my @rank = unpack "a" x $max_choices, $vote;
    foreach my $i (0..($max_choices - 1)) {
      foreach my $j (($i + 1)..($max_choices - 1)) {
        if ($rank[$i] eq '-' && $rank[$j] eq '-') {
          next;                 # Both unranked
        } elsif ($rank[$i] eq '-' && $rank[$j] ne '-') {
          $Beat_Matrix[$j][$i]++;
        } elsif ($rank[$i] ne '-' && $rank[$j] eq '-') {
          $Beat_Matrix[$i][$j]++;
        } elsif ($rank[$i] < $rank[$j]) {
          $Beat_Matrix[$i][$j]++;
        } elsif ($rank[$i] > $rank[$j]) {
          $Beat_Matrix[$j][$i]++;
        } else {
          next;                 # Equally ranked
        }
      }
    }
  }
  for my $opt (0..($max_choices - 1)) {
    print RESULTS "Option ", $opt + 1, " \"", $Config{"Option_" . ($opt + 1)},
      "\"\n";
  }
  print RESULTS <<EOF;

In the following table, tally[row x][col y] represents the votes that
option x received over option y.

EOF
  ;

  print RESULTS " " x18, "Option\n";
  print RESULTS " " x10;
  for my $col (0..($max_choices - 1)) {
    printf RESULTS " % 4d ", $col + 1;
  }
  print RESULTS "\n";
  print RESULTS " " x10, "  === " x $max_choices, "\n";
  for my $row (0..($max_choices - 1)) {
    printf RESULTS "Option %d  ", $row + 1;
    for my $col (0..($max_choices - 1)) {
      if ($row == $col) {
        printf RESULTS "      ", $Beat_Matrix[$row][$col];
      } else {
        printf RESULTS " % 4d ", $Beat_Matrix[$row][$col];
      }
    }
    print RESULTS "\n";
  }
  print RESULTS "\n\n";

  print RESULTS <<EOM;

Looking at row 2, column 1, $Config{Option_2}
received $Beat_Matrix[1][0] votes over $Config{Option_1}

Looking at row 1, column 2, $Config{Option_1}
received $Beat_Matrix[0][1] votes over $Config{Option_2}.

EOM
  ;

  my %Drop = ();

  foreach my $i (0..($max_choices - 2)) {
    if ($Beat_Matrix[$i][$max_choices - 1] < $K) {
      $Drop{$i}++;
      print RESULTS "Dropping Option", $i + 1, " \"", $Config{"Option_" . ($i + 1)}, 
        "\" because of Quorum\n";
    } else {
      print RESULTS "Option ", $i + 1, 
        " Reached quorum: $Beat_Matrix[$i][$max_choices - 1] > $K\n";
    }
  }

  print RESULTS "\n\n";

  #   2. An option A defeats the default option D by a majority ratio N,
  #   if V(A,D) is strictly greater than N * V(D,A).
  #   3. If a supermajority of S:1 is required for A, its majority ratio
  #   is S; otherwise, its majority ratio is 1.
  #  Any (non-default) option which does not defeat the default option
  #  by its required majority ratio is dropped from consideration.
  foreach my $i (0..($max_choices - 2)) {
    next unless $Beat_Matrix[$max_choices - 1][$i];
    next if $Drop{$i};

    my $ratio = $Beat_Matrix[$i][$max_choices - 1] /
      $Beat_Matrix[$max_choices - 1][$i];
    if ($ratio <= $Config{"Majority_" . ($i + 1)}) {
      # If the next line is commented out, we get a more verbose set of results
      $Drop{$i}++;
      print RESULTS "Dropping Option ", $i + 1, " because of Majority.";
      printf RESULTS " %6.3f (%d/%d) <= %d\n",
        $ratio, $Beat_Matrix[$i][$max_choices - 1],
          $Beat_Matrix[$max_choices - 1][$i],
            $Config{"Majority_" . ($i + 1)};
    } else {
      print RESULTS "Option ", $i + 1, " passes Majority.";
      print RESULTS "             ";
      printf RESULTS " %6.3f (%d/%d) > %d\n",
        $ratio, $Beat_Matrix[$i][$max_choices - 1],
          $Beat_Matrix[$max_choices - 1][$i],
            $Config{"Majority_" . ($i + 1)};
    }
  }
  print RESULTS "\n\n";

  my $done = 0;
  my %Defeats;
  # Initialize the Defeats matrix
  foreach my $i (0..($max_choices - 1)) {
    next if $Drop{$i};
    foreach my $j (($i + 1)..($max_choices - 1)) {
      next if $Drop{$j};
      if ($Beat_Matrix[$i][$j] > $Beat_Matrix[$j][$i]) {
        # i defeats j
        $Defeats{$i}{$j}{for}     = $Beat_Matrix[$i][$j];
        $Defeats{$i}{$j}{against} = $Beat_Matrix[$j][$i];

        print RESULTS "  Option ", $i + 1, " defeats Option ",
          $j + 1, sprintf(" by (% 4d - % 4d) = %4d votes.\n", $Beat_Matrix[$i][$j],
                          $Beat_Matrix[$j][$i], 
                          $Beat_Matrix[$i][$j] - $Beat_Matrix[$j][$i]);
      } elsif ($Beat_Matrix[$i][$j] < $Beat_Matrix[$j][$i]) {
        # j defeats i
        $Defeats{$j}{$i}{for}     = $Beat_Matrix[$j][$i];
        $Defeats{$j}{$i}{against} = $Beat_Matrix[$i][$j];
        print RESULTS "  Option ", $j + 1, " defeats Option ",
          $i + 1, sprintf(" by (% 4d - % 4d) = %4d votes.\n", $Beat_Matrix[$j][$i],
                          $Beat_Matrix[$i][$j], 
                          $Beat_Matrix[$j][$i] - $Beat_Matrix[$i][$j]);
      }
    }
  }
  print RESULTS "\n\n";
  my %BeatPath;
  my @Schwartz;
  # Ok, here is what we are here for.
  while (1) {

    # From the list of [undropped] pairwise defeats, we generate a set of
    # transitive defeats.

    # Initialize the Beatpath
    undef %BeatPath;
    foreach my $i (0..($max_choices - 1)) {
      next if $Drop{$i};
      foreach my $j (0..($max_choices - 1)) {
        next if $Drop{$j};
        $BeatPath{$i}{$j}{for}     = $Defeats{$i}{$j}{for};
        $BeatPath{$i}{$j}{against} = $Defeats{$i}{$j}{against};
      }
    }

    #   1. An option A transitively defeats an option C if A defeats C or
    #      if there is some other option B where A defeats B AND B
    #      transitively defeats C.
    while (!$done) {
      $done = 1;
      foreach my $i (0..($max_choices - 1)) {
        next if $Drop{$i};
        foreach my $j (0..($max_choices - 1)) {
          next if $Drop{$j};
          next if $i == $j;
          foreach my $k (0..($max_choices - 1)) {
            next if $Drop{$k};
            next if $i == $k;
            next if $k == $j;
            if (!$BeatPath{$i}{$j}{for}) {
              if ($BeatPath{$i}{$k}{for} && $BeatPath{$k}{$j}{for} ) {
                if ($BeatPath{$i}{$k}{for} == $BeatPath{$k}{$j}{for}) {
                  $BeatPath{$i}{$j}{for} = ($BeatPath{$i}{$k}{against} > 
                                            $BeatPath{$k}{$j}{against}) ?
                                              $BeatPath{$i}{$k}{for}:$BeatPath{$k}{$j}{for};
                  $BeatPath{$i}{$j}{against} = ($BeatPath{$i}{$k}{against} > 
                                                $BeatPath{$k}{$j}{against}) ?
                                                  $BeatPath{$i}{$k}{against} :
                                                    $BeatPath{$k}{$j}{against};
                } else {
                  $BeatPath{$i}{$j}{for} = ($BeatPath{$i}{$k}{for} < 
                                            $BeatPath{$k}{$j}{for}) ?
                                              $BeatPath{$i}{$k}{for} : 
                                                $BeatPath{$k}{$j}{for};
                  $BeatPath{$i}{$j}{against} = ($BeatPath{$i}{$k}{for} < 
                                                $BeatPath{$k}{$j}{for}) ?
                                                  $BeatPath{$i}{$k}{against} :
                                                    $BeatPath{$k}{$j}{against};
                }
                $done = 0;
              }
            }
          }
        }
      }
    }


    # We construct the Schwartz set from the set of transitive defeats.
    foreach my $i (0..($max_choices - 1)) {
      if ($Drop{$i}) {
        $Schwartz[$i] = 0;
      } else {
        $Schwartz[$i] = 1;
      }
    }

    foreach my $i (0..($max_choices - 1)) {
      foreach my $j (0..($max_choices - 1)) {
        next if $i == $j;
        # An option A is in the Schwartz set if for all options B, either
        # A transitively defeats B, or B does not transitively defeat A
        # Here, we throw out any option $i that does not meet the above
        # criteria.
        if (! ($BeatPath{$i}{$j}{for} || ! $BeatPath{$j}{$i}{for})) {
          $Schwartz[$i] = 0;
        }
      }
    }
    print RESULTS "The Schwartz Set contains:\n";
    foreach my $i (0 ..$#Schwartz) {
      next unless $Schwartz[$i];
      print RESULTS "\t Option ", ($i + 1), " \"", 
        $Config{"Option_" . ($i + 1)}, "\"\n";
    }
    print RESULTS "\n\n";

    # If there are defeats between options in the Schwartz set, we drop
    # the weakest such defeats from the list of pairwise defeats, and
    # return to step 5.

    #  1. A defeat (A,X) is weaker than a defeat (B,Y) if V(A,X) is
    #     less than V(B,Y). Also, (A,X) is weaker than (B,Y) if V(A,X) is
    #     equal to V(B,Y) and V(X,A) is greater than V(Y,B).

    #  2. A weakest defeat is a defeat that has no other defeat weaker
    #  than it. There may be more than one such defeat.

    # Check to see if there is anything in the Schwartz set that has no
    # defeats.
    my %Weakest;
    my $weak_count = 0;
    foreach my $i (0 ..$#Schwartz) {
      next unless $Schwartz[$i];
      foreach my $j (0..$#Schwartz) {
        next unless $Schwartz[$j];
        next if $i == $j;
        if (defined $Defeats{$i}{$j}{'for'}) {
          if (! $weak_count) {
            $Weakest{$weak_count}{'for'}     = $Defeats{$i}{$j}{for};
            $Weakest{$weak_count}{'against'} = $Defeats{$i}{$j}{against};
            $Weakest{$weak_count}{'Winner'}  = $i;
            $Weakest{$weak_count}{'Loser'}   = $j;
            $weak_count++;
          } elsif ($Weakest{0}{'for'} > $Defeats{$i}{$j}{for}) {
            undef %Weakest;
            $weak_count = 0;
            $Weakest{$weak_count}{'for'}     = $Defeats{$i}{$j}{for};
            $Weakest{$weak_count}{'against'} = $Defeats{$i}{$j}{against};
            $Weakest{$weak_count}{'Winner'}  = $i;
            $Weakest{$weak_count}{'Loser'}   = $j;
            $weak_count++;
          } elsif ($Weakest{0}{'for'} == $Defeats{$i}{$j}{'for'}) {
            if ($Weakest{0}{'against'} < $Defeats{$i}{$j}{against}) {
              undef %Weakest;
              $weak_count = 0;
              $Weakest{$weak_count}{'for'}     = $Defeats{$i}{$j}{for};
              $Weakest{$weak_count}{'against'} = $Defeats{$i}{$j}{against};
              $Weakest{$weak_count}{'Winner'}  = $i;
              $Weakest{$weak_count}{'Loser'}   = $j;
              $weak_count++;
            } else {
              $Weakest{$weak_count}{'for'}     = $Defeats{$i}{$j}{'for'};
              $Weakest{$weak_count}{'against'} = $Defeats{$i}{$j}{'against'};
              $Weakest{$weak_count}{'Winner'}  = $i;
              $Weakest{$weak_count}{'Loser'}   = $j;
              $weak_count++;
            }
          }
        }
        if (defined $Defeats{$j}{$i}{'for'}) {
          if (! $weak_count) {
            $Weakest{$weak_count}{'for'}     = $Defeats{$j}{$i}{'for'};
            $Weakest{$weak_count}{'against'} = $Defeats{$j}{$i}{'against'};
            $Weakest{$weak_count}{'Winner'}  = $j;
            $Weakest{$weak_count}{'Loser'}   = $i;
            $weak_count++;
          } elsif ($Weakest{0}{'for'} > $Defeats{$j}{$i}{'for'}) {
            undef %Weakest;
            $weak_count = 0;
            $Weakest{$weak_count}{'for'}     = $Defeats{$j}{$i}{'for'};
            $Weakest{$weak_count}{'against'} = $Defeats{$j}{$i}{'against'};
            $Weakest{$weak_count}{'Winner'}  = $j;
            $Weakest{$weak_count}{'Loser'}   = $i;
            $weak_count++;
          } elsif ($Weakest{0}{'Low'} == $Defeats{$j}{$i}{'for'}) {
            if ($Weakest{0}{'against'} < $Defeats{$j}{$i}{'against'}) {
              undef %Weakest;
              $weak_count = 0;
              $Weakest{$weak_count}{'for'}    = $Defeats{$j}{$i}{'for'};
              $Weakest{$weak_count}{'against'} = $Defeats{$j}{$i}{'against'};
              $Weakest{$weak_count}{'Winner'} = $j;
              $Weakest{$weak_count}{'Loser'}  = $i;
              $weak_count++;
            } else {
              $Weakest{$weak_count}{'for'}     = $Defeats{$j}{$i}{'for'};
              $Weakest{$weak_count}{'against'} = $Defeats{$j}{$i}{'against'};
              $Weakest{$weak_count}{'Winner'}  = $j;
              $Weakest{$weak_count}{'Loser'}   = $i;
              $weak_count++;
            }
            
          }
        }
      }
    }
    if (! $weak_count) {
      print RESULTS "\n", "-=" x 35, "\n";
      print RESULTS "-=" x 35, "\n\n";
      print RESULTS "The winners are:\n";
      foreach my $i (0 ..$#Schwartz) {
        next unless $Schwartz[$i];
        print RESULTS "\t Option ", ($i + 1), " \"", 
          $Config{"Option_" . ($i + 1)}, "\"\n";
      }
      print RESULTS "\n", "-=" x 35, "\n";
      print RESULTS "-=" x 35, "\n\n";
      last;
    } else {
      print RESULTS "Weakest Defeat(s): \n";
      foreach my $k (sort keys %Weakest) {
        print RESULTS "\tOption ", $Weakest{$k}{'Winner'} + 1, " beats Option ",
          $Weakest{$k}{'Loser'} + 1, " by ",
            " ($Beat_Matrix[$Weakest{$k}{'Winner'}][$Weakest{$k}{'Loser'}] - ",
              "$Beat_Matrix[$Weakest{$k}{'Loser'}][$Weakest{$k}{'Winner'}])\t",
                "= ", $Weakest{$k}{'for'} - $Weakest{$k}{'against'}, " votes\n";
      }
      print RESULTS "Deleting weakest defeat(s)\n\n";
      foreach my $k (sort keys %Weakest) {
        delete $Defeats{$Weakest{$k}{'Winner'}}{$Weakest{$k}{'Loser'}};
      }
    }
  }
  # Create the graphical results file in dot format.
  open (GRAPH, ">$graph") || die "Could not open $graph:$!";
  chmod $Config{"File_Mask"}, "$graph";
  # The header. This is a directed graph.
  print GRAPH "digraph Results {\n  ranksep=0.25;\n";
  foreach my $i (0..($max_choices - 1)) {
    # At this point, the Schwartz set is in place and contains all the
    # winners (who get a different color fill)

    # Print Node information.
    print GRAPH " \"", $Config{"Option_" . ($i + 1)}, "\" [ style=\"filled\" ";
    if ($Schwartz[$i]) {
      print GRAPH ", color=\"powderblue\", shape=egg, fontcolor=\"Navy Blue\"";
    }
    if ($i == ($max_choices - 1)) {
      print GRAPH ", shape=diamond, fontcolor=\"Red\"";
    }
    if ($Drop{$i}) {
      print GRAPH ", color=\"pink\", shape=octagon";
    }
    print GRAPH ", fontname=\"Helvetica\", fontsize=10  ];\n";

    if ($Drop{$i}) {
      if ($Beat_Matrix[$i][$max_choices - 1] >= $K) {
        # it met quorum, but still was dropped.
        # probably since it did not meet majority
        my $label = $Beat_Matrix[$max_choices -1][$i] - 
          $Beat_Matrix[$i][$max_choices -1];
        # my $win;
        # $win = $label;
        # "weight=", ((($win<0)?-1:1) * 1000/$win),
        print GRAPH " \"", $Config{"Option_" . $max_choices}, "\" -> \"",
          $Config{"Option_" . ($i + 1)}, "\" [ label=\"$label\" ];\n";
      }
    }
    foreach my $j (0..($max_choices - 1)) {
      next if $i == $j;
      #  The beatpath should take into account transitive wins, and
      #  have had all the weakest links removed, if needed, to resolve
      #  circular ties.
      if ($BeatPath{$i}{$j}{for}) {
        # my $win   = $BeatPath{$i}{$j}{for};
        # $win   -= $BeatPath{$j}{$i}{against}
        #  if defined $BeatPath{$j}{$i}{against};
        # "weight=", (1000/$win),

        # We still use the simple two way contest margins to label the
        # edge, since anything else is likely to confuse people.
        my $label = $Beat_Matrix[$i][$j] - $Beat_Matrix[$j][$i];

        # Print the edge information.
        print GRAPH " \"", $Config{"Option_" . ($i + 1)}, "\" -> \"",
          $Config{"Option_" . ($j + 1)}, "\" [ label=\"$label\" ];\n";
      }
    }
  }
  # The footer.
  print GRAPH "}\n";

}


sub main {
  my $optdesc = Devotee->Optdesc();
  GetOptions (%$optdesc);
  my $dvt = Devotee->new(%::ConfOpts);
  $dvt->validate(%::ConfOpts) unless 
    defined $::ConfOpts{'Config File'} && -r $::ConfOpts{'Config File'};
  &winner('Configuration' => $dvt);
}

&main;

exit 0;


=head1 CAVEATS

This is very inchoate, at the moment, and needs testing.

=cut

=head1 BUGS

None Known so far.

=cut

=head1 AUTHOR

Manoj Srivastava <srivasta@debian.org>

=head1 COPYRIGHT AND LICENSE

This script is a part of the Devotee package, and is 

Copyright (c) 2002, 2003, 2004, 2005  Manoj Srivastava <srivasta@debian.org>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=cut



1;

__END__

