#!/usr/bin/perl -w
#                              -*- Mode: Perl -*- 
# dvt-nack --- 
# Author           : Manoj Srivastava ( srivasta@glaurung.green-gryphon.com ) 
# Created On       : Fri Mar 29 17:59:36 2002
# Created On Node  : glaurung.green-gryphon.com
# Last Modified By : Manoj Srivastava
# Last Modified On : Tue Apr 15 02:55:18 2003
# Last Machine Used: glaurung.green-gryphon.com
# Update Count     : 39
# Status           : Unknown, Use with caution!
# HISTORY          : 
# Description      : 
# 
# 

use strict;

require 5.005;
use Carp qw(carp croak);
use Devotee;
use Getopt::Long;

use MIME::Entity;
use MIME::Parser;
use MIME::Decoder;
use MIME::Tools;
use MIME::Decoder::Binary;

=head1 NAME

debvote-mime - From the work dir, decode and save the body of the message

=cut

=head1 SYNOPSIS

This routine is designed to handle various forms of MIME
encampulation, including PGP?MIME, and create a decoded body text in a
format that can be easily checked for cryptograhic signatures.

=cut

=head1 DESCRIPTION

The idea here is to be forgiving of MIME errors and be able to present
as many signed votes toi the signature verifier as possible.

Additionally, this script attempts to be idepotent. It is also
incremental, unless a force option is given. in which case it
re-decodes previously decoded messages.

=cut

=head2 Internal Implementation

=cut

sub send_mail {
  my %params = @_;

  die "Required parameter 'Destination' missing" unless
    defined $params{'Destination'};
  die "Required parameter 'Subject' missing" unless
    defined $params{'Subject'};
  die "Required parameter 'BGody' missing" unless
    defined $params{'Body'};

  open(MAIL, "| /usr/sbin/sendmail -t") || die "Cannot open sendmail";
# open(MAIL, ">>Nacks")                 || die "Cannot open sendmail";
  print MAIL <<EOH;
From: secretary\@debian.org
To: $params{'Destination'}
Bcc: secretary\@debian.org
Subject: $params{'Subject'}

Hi,

$params{'Body'}

-- 
Debian Project secretary (secretary\@debian.org)

EOH
  ;
  close(MAIL);

}


sub send_nack {
  my %params   = @_;
  die "Internal Error!" unless defined $params{'Configuration'};
  my $confref = $params{'Configuration'}->get_config_ref();
  my $dvt = $params{'Configuration'};
  my %Config = %{ $confref };

  my $topdir      = $Config{'Top_Dir'};
  my $workdir     = $Config{'Work_Dir'};
  my $bodydir     = $Config{'Body_Dir'};
  my $logdir      = $Config{'Log_Dir'};
  my $tallydir    = $Config{'Tally_Dir'};
  my $nackdir     = $Config{'Nack_Dir'};
  my $sigdir      = $Config{'Sig_Dir'};
  my $tmpdir      = $Config{'Temp_Dir'};
  my $ldapdir     = $Config{'LDAP_Dir'};

  my $lock_suffix = $Config{'Lock_Suffix'};
  my $msg_suffix  = $Config{'Msg_Suffix'};
  my $msg_preffix = $Config{'Msg_Preffix'};
  my $common_lock = $Config{'Common_Lock'};

  my $force       = $Config{'Force'};

  my $body_suffix = $Config{'Body_Suffix'};
  my $sig_suffix  = $Config{"Sig_Suffix"};


  opendir(NACK, $nackdir) || die "can't opendir $nackdir: $!";
  my @messages = grep { m/${msg_preffix}\d+\.${msg_suffix}$/ &&
                        -f  "$workdir/$_" }   readdir(NACK);
  closedir(NACK);

  foreach my $msg (sort @messages) {
    my $msg_base = $msg;
    $msg_base =~ s/\.$msg_suffix$//o;
    next if !$force && -e "$nackdir/$msg_base.sent";

    my $ret = open(ERR, "$nackdir/$msg");
    if (!$ret) {
      &log_message($msg, "Error reading errors from $nackdir/$msg:$!");
      next;
    }
    undef $/;
    my $err_msg = <ERR>;
    $/ = "\n";
    my $parser = new MIME::Parser;
    $parser->output_dir("$tmpdir");
    $parser->output_to_core(0);
    my $entity;
    eval {$entity = $parser->parse_open("$workdir/$msg"); };
    if ($@) {
      &log_message($msg, "Could not parse message $msg");
      next;
    }
    my $head        = $entity->head;
    my $from        = $head->get('From');
    my $replyto     = $head->get('Reply-To');
    my $date        = $head->get('Date');
    my $origsubject = $head->get('Subject');
    my $messageid   = $head->get('Message-ID');
    chomp($from)          if $from;
    chomp($date)          if $date;
    chomp($origsubject)   if $origsubject;
    chomp($replyto)       if $replyto;
    chomp($messageid)     if $messageid;
    if ($replyto) {
      $from = $replyto;
    }
    my $subject = "Error report for your vote";

    my $body = '';
    $body  = "\tThis is an error report about your vote [record $msg]\n";
    $body .= " sent in on $date" if $date;
    $body .= ", with the subject\n \"$origsubject\"\n" if $origsubject;
    $body .= "\n"                                  unless $origsubject;
    $body .= " The message ID is $messageid.\n"       if $err_msg;
    $body .= " The folowing errors were reported:\n" if $err_msg;
    $body .= "-=" x 35 . "\n" if $err_msg;
    $body .= $err_msg         if $err_msg;
    $body .= "-=" x 35 . "\n" if $err_msg;
    $body .= "\tIf you have already voted again, please ignore this.\n";

    my $now_string  = gmtime;
    $body .= "\n  The time now is $now_string\n";
    $body .= "\n\tThanks for your participation.\n";

    &send_mail('Destination' => "$from",
	       'Subject'     => "$subject",
	       'Body'        => "$body");
    $ret = open(SENT, ">>$nackdir/$msg_base.sent");
    if (!$ret) {
      &log_message($msg, "Error logging mesage $nackdir/$msg_base.sent:$!");
      next;
    }
    chmod 0660, "$nackdir/$msg_base.sent";
    print SENT "Sent NACK to $from at $now_string\n";
    close SENT;
  }

}


sub main {
  my $optdesc = Devotee->Optdesc();
  GetOptions (%$optdesc);
  my $dvt = Devotee->new(%::ConfOpts);
  $dvt->validate(%::ConfOpts) unless 
    defined $::ConfOpts{'Config File'} && -r $::ConfOpts{'Config File'};
  $dvt->lock_vote_dir();
  &send_nack('Configuration' => $dvt);
  $dvt->unlock_vote_dir();
}

&main;

exit 0;
